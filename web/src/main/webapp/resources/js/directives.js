// Generated by CoffeeScript 1.6.2
(function() {
  define(["angular", "services", "jquery", "nv", "moment", 'd3Logic', 'utils'], function(angular, services, $, nv, moment, d3Logic, utils) {
    "use strict";    return angular.module("rhphd.directives", ["rhphd.services"]).directive("appVersion", [
      "version", function(version) {
        return function(scope, elm, attrs) {
          return elm.text(version);
        };
      }
    ]).directive('json', function() {
      return {
        require: 'ngModel',
        link: function(scope, elm, attrs, ctrl) {
          return ctrl.$parsers.unshift(function(viewValue) {
            var e;

            if (viewValue === void 0 || viewValue === '') {
              ctrl.$setValidity('json', true);
              return viewValue;
            }
            try {
              JSON.parse(viewValue);
              ctrl.$setValidity('json', true);
              return viewValue;
            } catch (_error) {
              e = _error;
              ctrl.$setValidity('json', false);
              return void 0;
            }
            return true;
          });
        }
      };
    }).directive("d3Tree", function($timeout) {
      return {
        restrict: "E",
        scope: {
          val: "="
        },
        link: function(scope, element, attrs) {
          var chart, containerSelector, createTree, dataSet, duration, elementId, handleTree, updateTree;

          elementId = element.attr('id');
          containerSelector = "#" + elementId;
          dataSet = void 0;
          chart = void 0;
          duration = 500;
          createTree = function() {
            chart = nv.models.indentedTree().iconOpen("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wBBBQgHxiJ6ugAAADXSURBVDjL1ZKhDsJADIb/Ed6BZ0ABAoVBIpFIECRI3J5hbh7DI2BxGBQKhT0HCYJ/rqgijttu3Bg4QpNL2qRf/7ZX4O8tcs75etPt/mgDKRL4Eg96LfQ77SiotN7sNDdRpXtUNVQ1F6ox1O5oqj7XCCrdgcz54jrIAAEMGaQXBSSEh5NZDhNABV/uIFAudVG9xGZpWb7y08aLpd1RmtYX8NU26xQQCzuQAlBYP4K/MD+V8v4Oyr/gw2LbroMrRzCkhcSp87tLPBxPOo+Tj6e7SuLqS/yZPQAbdn01WTa53QAAAABJRU5ErkJggg==").iconClose("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wBBBQeNPXwCNUAAAC0SURBVDjLY2AY8oARxnj++v3/nUcvQjg/EAo+oPGtDcUZTPU1GTFMWrDhwH84+PH//wcY/vD//4MP//8/ePHh/4MHH/4beCT8R9bHhGHSTwaGjzD2D5gLPiLYaABhwA8iNP/AZwAD6ZoZGBgYWFACC6rQISIRM4wmTGD48AOPAcg2b1gwAcPmDzhcgOIFXM7GpRkzFghp/kHQAPyaP+BLiacvXv+fWt5JMOnO7izHnhIHDAAALe92s7vgY+oAAAAASUVORK5CYII=").tableClass('table table-striped').columns([
              {
                key: 'key',
                label: 'Entity',
                showCount: true,
                width: '75%',
                type: 'text',
                classes: function(d) {
                  if (d.url != null) {
                    return 'clickable name';
                  } else {
                    return 'name';
                  }
                },
                click: function(d) {
                  if (d.url != null) {
                    return window.location.href = d.url;
                  } else {
                    return void 0;
                  }
                }
              }, {
                key: 'type',
                label: 'Type',
                width: '25%',
                type: 'text'
              }
            ]);
          };
          updateTree = function() {
            d3.select(containerSelector).datum(dataSet).transition().duration(duration).call(chart);
            chart.update();
          };
          handleTree = function() {
            if (chart === void 0) {
              return nv.addGraph(function() {
                createTree();
                d3.select(containerSelector).datum(dataSet).transition().duration(duration).call(chart);
                nv.utils.windowResize(chart.update);
                return chart;
              });
            } else {
              return updateTree();
            }
          };
          scope.$watchCollection("val", function(newVal) {
            if (newVal) {
              dataSet = newVal;
              return handleTree();
            }
          });
          $(window).resize(function() {
            var innerHeight;

            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
              innerHeight = $(window).innerHeight();
              return $(containerSelector).height(innerHeight);
            }
          });
          if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
            return $timeout((function() {
              return $(window).trigger('resize');
            }), 300);
          }
        }
      };
    }).directive("d3Metric", [
      '$interpolate', "$timeout", "metricService", function($interpolate, $timeout, metricService) {
        return {
          restrict: "E",
          scope: {
            machine: "=",
            metric: "=",
            metricName: "@",
            type: "@",
            legend: "=",
            limit: "@",
            max: "@"
          },
          link: function(scope, element, attrs) {
            var chart, chartType, chartXType, containerSelector, createChartByType, dataSet, duration, elementId, handleBubble, handleChart, handleOptionsChanges, handlePie, height, limit, machine, margin, max, metric, metricName, resetSvg, setAxisFormatting, showLegend, svgElement, svgSelector, updateChartByType;

            elementId = void 0;
            containerSelector = void 0;
            svgSelector = void 0;
            svgElement = element.children('svg')[0];
            machine = void 0;
            metric = void 0;
            metricName = void 0;
            dataSet = void 0;
            chartType = "discreteBarChart";
            chart = void 0;
            chartXType = void 0;
            showLegend = true;
            max = false;
            limit = void 0;
            duration = 1000;
            height = 400;
            margin = {
              top: 10,
              right: 50,
              bottom: 50,
              left: 70
            };
            setAxisFormatting = function(dataSet) {
              return chart.xAxis.tickFormat(function(d) {
                return moment(d).format('MM-DD HH:mm:ss');
              });
            };
            createChartByType = function() {
              if (chartType === 'multiBarChart') {
                chart = nv.models.multiBarChart().margin(margin).x(function(d) {
                  return d.x;
                }).y(function(d) {
                  return d.y;
                }).tooltip(function(key, x, y, e, graph) {
                  return "<h3>" + key + "</h3><p>" + y + " on " + x + "</p>";
                }).showLegend(showLegend);
              }
              if (chartType === 'discreteBarChart') {
                chart = nv.models.discreteBarChart().margin(margin).x(function(d) {
                  return d.x;
                }).y(function(d) {
                  return d.y;
                });
              } else if (chartType === 'stackedAreaChart') {
                chart = nv.models.stackedAreaChart().margin(margin).x(function(d) {
                  return d.x;
                }).y(function(d) {
                  return d.y;
                }).clipEdge(true).tooltip(function(key, x, y, e, graph) {
                  return "<h3>" + key + "</h3><p>" + y + " on " + x + "</p>";
                }).showLegend(showLegend);
              } else if (chartType === 'line') {
                chart = nv.models.lineChart().margin(margin).x(function(d) {
                  return d.x;
                }).y(function(d) {
                  return d.y;
                }).showLegend(showLegend);
              } else if (chartType === 'lineWithFocusChart') {
                chart = nv.models.lineWithFocusChart().margin(margin).x(function(d) {
                  return d.x;
                }).y(function(d) {
                  return d.y;
                }).showLegend(showLegend);
              }
              return void 0;
            };
            updateChartByType = function() {
              if (_.contains(['multiBarChart', 'discreteBarChart', 'stackedAreaChart', 'line', 'lineWithFocusChart'], chartType)) {
                setAxisFormatting(dataSet);
                d3.select(svgElement).datum(dataSet).transition().duration(duration).call(chart);
                if (typeof chart.update === "function") {
                  chart.update();
                }
              }
              return void 0;
            };
            handleChart = function() {
              if (chart === void 0) {
                return nv.addGraph(function() {
                  createChartByType();
                  setAxisFormatting(dataSet);
                  d3.select(svgElement).datum(dataSet).transition().duration(duration).call(chart);
                  nv.utils.windowResize(chart.update);
                  return chart;
                });
              } else {
                return updateChartByType();
              }
            };
            handlePie = function() {
              if (chart === void 0) {
                return nv.addGraph(function() {
                  chart = nv.models.pieChart().x(function(d) {
                    return d.key;
                  }).y(function(d) {
                    return d.y;
                  }).showLabels(true);
                  d3.select(svgElement).datum(dataSet).transition().duration(duration).call(chart);
                  chart.update();
                  nv.utils.windowResize(chart.update);
                  return chart;
                });
              } else {
                d3.select(svgElement).datum(dataSet).transition().duration(duration).call(chart);
                return typeof chart.update === "function" ? chart.update() : void 0;
              }
            };
            handleBubble = function() {
              chart = new Bubble("graph_container");
              chart.initialize_data(dataSet);
              chart.start();
              return chart.display_group_all();
            };
            handleOptionsChanges = function() {
              var opts;

              if ((machine != null) && ((metric != null) || (metricName != null)) && (chartType != null)) {
                opts = {
                  machineId: machine._id,
                  group: metric.group,
                  name: metric.name
                };
                if (_.isNumber(utils.parseInteger(scope.limit))) {
                  limit = parseInt(scope.limit);
                  opts.limit = limit;
                }
                max = utils.truthy(scope.max);
                return metricService.getMetrics(opts, function(data) {
                  opts = {
                    machine: machine,
                    metric: metric,
                    data: data,
                    limit: limit,
                    max: max,
                    chartType: chartType
                  };
                  return d3Logic.transformMetricData(opts, function(d3Data) {
                    dataSet = d3Data;
                    if ((dataSet != null ? dataSet.length : void 0) > 0) {
                      if (chartType === 'multiBarChart' || chartType === 'discreteBarChart' || chartType === 'stackedAreaChart' || chartType === 'line' || chartType === 'lineWithFocusChart') {
                        return handleChart();
                      } else if (chartType === 'bubble') {
                        return handleBubble();
                      } else if (chartType === 'pie') {
                        return handlePie();
                      } else {
                        return console.warn("Data to graph but no type of Graph selected!");
                      }
                    } else {
                      return console.warn("No data given to graph!");
                    }
                  });
                });
              }
            };
            resetSvg = function() {
              chart = void 0;
              console.debug("Resetting SVG");
              $(element).children().remove();
              return $(element).append("svg");
            };
            scope.$watch("type", function(newVal, oldVal) {
              if (newVal) {
                chartType = newVal;
                if (newVal !== oldVal && newVal !== void 0) {
                  resetSvg();
                }
                return handleOptionsChanges();
              }
            });
            scope.$watch("metric", function(newVal, oldVal) {
              if (newVal) {
                metric = utils.parseToJson(newVal);
                if (metric.type != null) {
                  chartType = metric.type;
                }
                return handleOptionsChanges();
              }
            });
            scope.$watch("metricName", function(newVal, oldVal) {
              if (newVal) {
                metric = utils.parseMetricName(newVal);
                return handleOptionsChanges();
              }
            });
            return scope.$watch("machine", function(newVal, oldVal) {
              if (newVal && (newVal._id !== (oldVal != null ? oldVal._id : void 0))) {
                machine = newVal;
                return handleOptionsChanges();
              }
            });
          }
        };
      }
    ]);
  });

}).call(this);
