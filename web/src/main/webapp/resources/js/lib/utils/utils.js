// Generated by CoffeeScript 1.6.2
(function() {
  define(['underscore', 'moment'], function(_, moment) {
    var utils;

    utils = {};
    utils.truthy = function(obj) {
      if (obj === void 0) {
        return false;
      } else if (_.isBoolean(obj)) {
        return obj;
      } else if (_.isString(obj)) {
        if (_.contains(['YES', 'yes', 'Y', 'y', '1', 'true', 'TRUE', 'ok', 'OK'], obj)) {
          return true;
        } else {
          return false;
        }
      } else if (_.isNumber(obj)) {
        return parseInt(obj) === 1;
      } else {
        return false;
      }
    };
    utils.isInteger = function(f) {
      return f !== void 0 && typeof f === 'number' && Math.round(f) === f;
    };
    utils.isFloat = function(f) {
      return f !== void 0 && typeof f === 'number' && !utils.isInteger(f);
    };
    utils.stringify = function(obj) {
      if (_.isString(obj)) {
        return obj;
      } else if (_.isObject(obj)) {
        return JSON.stringify(obj);
      }
      return obj;
    };
    utils.parseToJson = function(data) {
      if (typeof data === "object") {
        return data;
      } else if (data === "") {
        return void 0;
      } else if (data === void 0) {
        return void 0;
      } else {
        return JSON.parse(data);
      }
    };
    utils.parseInteger = function(n) {
      if (_.isNumber(n)) {
        return n;
      } else if (typeof n === "object") {
        return void 0;
      } else if (n === void 0) {

      } else if (n === "") {
        return void 0;
      } else if (n === void 0) {
        return void 0;
      } else {
        return parseInt(n);
      }
    };
    utils.parseMetricName = function(input) {
      var metric, splitInput;

      splitInput = input.split(':');
      if (splitInput.length !== 2) {
        return console.error("d3Metric attribute metric-name requires a group:name input");
      } else {
        metric = {
          group: splitInput[0],
          name: splitInput[1]
        };
        return metric;
      }
    };
    utils.isUnixOffset = function(theInput) {
      return /[0-9]{13}/.test(theInput);
    };
    utils.isUnixTimestamp = function(theInput) {
      return /[0-9]{10}/.test(theInput) && String(theInput).length === 10;
    };
    utils.parseDateToOffset = function(theDate, opts) {
      var format, isUnixOffset, isUnixTimestamp, pFormat, utc;

      if (opts == null) {
        opts = {};
      }
      format = opts != null ? opts.format : void 0;
      utc = (opts != null ? opts.utc : void 0) || true;
      isUnixOffset = utils.isUnixOffset(theDate);
      isUnixTimestamp = utils.isUnixOffset(theDate);
      pFormat = (function() {
        switch (format) {
          case 'year':
            return 'YYYY';
          case 'month':
            return 'YYYY-MM';
          case 'day':
            return 'YYYY-MM-DD';
          case 'hour':
            return 'YYYY-MM-DD HH';
          case 'minute':
            return 'YYYY-MM-DD HH:mm';
          case 'second':
            return 'YYYY-MM-DD HH:mm:ss';
          default:
            return void 0;
        }
      })();
      if (isUnixOffset) {
        if (utc) {
          return +moment.utc(theDate);
        } else {
          return +moment(theDate);
        }
      } else if (isUnixTimestamp) {
        return +moment.unix(theDate);
      }
      if (_.isDate(theDate)) {
        return +moment.utc(theDate);
      } else if (format === 'year' && _.isNumber(theDate)) {
        if (utc) {
          return +moment.utc(String(theDate), pFormat);
        } else {
          return +moment(String(theDate), pFormat);
        }
      } else {
        if (utc) {
          return +moment.utc(theDate, pFormat);
        } else {
          return +moment(theDate, pFormat);
        }
      }
    };
    return utils;
  });

}).call(this);
